---
description: story related
globs: 
alwaysApply: false
---
# Storybook Guidelines

## Architecture Overview
- Stories are implemented as GObject-based GTK widgets
- Story classes are registered with a central registry
- Story instances are created only when the GTK environment is ready
- Each story has its own UI template to ensure correct class names and properties
- Use the `StoryRegistry` service for centralized story management

## Story Structure
- Create stories as classes extending the `StoryWidget` base class
- Define abstract base classes for common story functionality
- Create variant subclasses for different configurations of the same component
- Register story classes (not instances) with the registry
- Follow the title format `'Category/Name'` for consistent organization
- Group related widgets in the same category
- Implement the `StoryModule` interface to group related stories

## Widget Implementation
- Create separate `.story.ts` files for each component
- Define separate `.story.blp`/`.story.ui` files for each variant
- Set default property values in the Blueprint template when possible
- Define internal child widgets in the GObject class registration
- Implement proper error handling in all widget methods
- Override `initialize()` to set up the widget after creation
- Override `updateArgs()` to handle property changes

## UI Templates
- Each story variant should have its own Blueprint template
- Use proper widget class names in templates
- Define dimensions and static properties in the template
- Follow GTK's spacing and margin guidelines
- Use clear widget IDs that match their purpose
- Reference templates directly with `?raw` import syntax

## Control Types
- Use appropriate `ControlType` from the enum (not string literals)
- Configure proper constraints for numeric controls
- Provide comprehensive options for select controls
- Include descriptive labels and tooltips
- Handle property changes efficiently
- Group related controls logically

## Error Handling
- Check for null/undefined values before use
- Use try/catch blocks for error-prone operations 
- Log meaningful error messages
- Use Promise chaining with proper error handlers
- Provide graceful fallbacks when operations fail
- Check widget state before performing actions

## Type Safety
- Use proper TypeScript types and interfaces
- Avoid `any` type - use generic types with constraints
- Define clear interfaces for story components
- Use type guards for runtime checks
- Create custom types for complex structures
- Use proper nullability handling

## Documentation
- Document all public classes, methods, and properties
- Use consistent JSDoc style comments
- Include parameter and return type descriptions
- Document expected behavior and edge cases
- Add examples for complex usage patterns
- Comment non-obvious code sections